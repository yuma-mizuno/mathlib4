/-
Copyright (c) 2025 BenoÃ®t Guillemet. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz, BenoÃ®t Guillemet
-/
module

public import Mathlib.CategoryTheory.Sites.Hypercover.Zero
public import Mathlib.CategoryTheory.Sites.SheafOfTypes

/-!

# Grothendieck topology generated by a precoverage

For any category `C`, we define the Grothendieck topology generated by a precoverage `J` on `C`.
It is the smallest Grothendieck topology containing all the sieves generated by the covering
presieves of `J`.

The main definitions and theorems are:
- `Precoverage.toGrothendieck`: The Grothendieck topology generated by the sieves generated by the
  covering presieves of `J`.
- `Precoverage.toGrothendieck_eq_sInf`: The Grothendieck topology generated by `J` is the infimum
  of the Grothendieck topologies containing all the sieves generated by the covering presieves
  of `J`.
- `Presieve.isSheaf_toGrothendieck_iff`: Given `J : Precoverage C` with associated Grothendieck
  topology `K`, a `Type*`-valued presheaf on `C` is a sheaf for `K` if and only if it is a sheaf
  for all pullbacks of the covering presieves of `J`.
-/

@[expose] public section

namespace CategoryTheory

variable {C : Type _} [Category C]

namespace Precoverage

variable {J : Precoverage C}

/--
An auxiliary definition used to define the Grothendieck topology associated to a precoverage.
See `Precoverage.toGrothendieck`.
-/
inductive Saturate (J : Precoverage C) : (X : C) â†’ Sieve X â†’ Prop where
  | of (X : C) (S : Presieve X) (hS : S âˆˆ J X) : J.Saturate X (Sieve.generate S)
  | top (X : C) : J.Saturate X âŠ¤
  | pullback (X : C) (S : Sieve X) : J.Saturate X S â†’ âˆ€ (Y : C) (f : Y âŸ¶ X),
      J.Saturate Y (S.pullback f)
  | transitive (X : C) (S R : Sieve X) : J.Saturate X S â†’
      (âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S f â†’ J.Saturate Y (R.pullback f)) â†’ J.Saturate X R

/--
The Grothendieck topology associated to a precoverage `J`.
It is defined *inductively* as follows:
1. If `S` is a covering presieve for `J`, then the sieve generated by `S` is a covering
  sieve for the associated Grothendieck topology.
2. The top sieves are in the associated Grothendieck topology.
3. Add all sieves required by the pullback stability condition of a Grothendieck topology.
4. Add all sieves required by the *local character* axiom of a Grothendieck topology.
-/
def toGrothendieck (J : Precoverage C) : GrothendieckTopology C where
  sieves := J.Saturate
  top_mem' := .top
  pullback_stable' _ _ _ _ hS := .pullback _ _ hS _ _
  transitive' _ _ hS _ hR := .transitive _ _ _ hS hR

lemma mem_toGrothendieck_iff {X : C} {S : Sieve X} :
    S âˆˆ J.toGrothendieck X â†” J.Saturate X S := .rfl

@[grind .]
lemma generate_mem_toGrothendieck {X : C} {R : Presieve X} (hR : R âˆˆ J X) :
    Sieve.generate R âˆˆ J.toGrothendieck X :=
  .of _ _ hR

@[gcongr]
lemma toGrothendieck_mono {J K : Precoverage C} (h : J â‰¤ K) :
    J.toGrothendieck â‰¤ K.toGrothendieck := by
  intro X S hS
  induction hS with
  | of X S hS => exact generate_mem_toGrothendieck (h _ hS)
  | top X => simp
  | pullback X S _ Y f _ => grind
  | transitive X S R _ _ _ _ => grind

/--
An alternative characterization of the Grothendieck topology associated to a precoverage `J`:
it is the infimum of all Grothendieck topologies containing `Sieve.generate S` for all presieves
`S` in `J`.
-/
lemma toGrothendieck_eq_sInf (J : Precoverage C) :
    J.toGrothendieck =
      sInf { K | âˆ€ â¦ƒX : Câ¦„ (S : Presieve X), S âˆˆ J X â†’ Sieve.generate S âˆˆ K X } := by
  refine le_antisymm ?_ ?_
  Â· rw [le_sInf_iff]
    intro K hK _ _ hS
    induction hS with
    | of _ _ hS => exact hK _ hS
    | top => exact K.top_mem _
    | pullback _ _ _ _ _ ih => exact K.pullback_stable _ ih
    | transitive _ _ _ _ _ ih1 ih2 => exact K.transitive ih1 _ ih2
  Â· exact sInf_le (fun _ _ hS => .of _ _ hS)

/--
The main theorem of this file: given a precoverage `J` on `C`, a `Type*`-valued presheaf on `C` is
a sheaf for the associated Grothendieck topology if and only if it is a sheaf for all pullback
sieves of presieves in `J`.
-/
theorem isSheaf_toGrothendieck_iff (P : Cáµ’áµ– â¥¤ Type*) :
    Presieve.IsSheaf J.toGrothendieck P â†”
      (âˆ€ {X Y : C} {f : Y âŸ¶ X} (R : Presieve X), R âˆˆ J X â†’
        Presieve.IsSheafFor P ((Sieve.generate R).pullback f).arrows) := by
  constructor
  Â· refine fun H _ _ _ _ hR => H.isSheafFor _ _ ?_
    rw [Sieve.generate_sieve]
    exact J.toGrothendieck.pullback_stable _ (Saturate.of _ _ hR)
  Â· intro H X S hS
    -- This is the key point of the proof:
    -- We must generalize the induction in the correct way.
    suffices âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X), Presieve.IsSheafFor P (S.pullback f).arrows by
      simpa using this (f := ğŸ™ _)
    induction hS with
    | of X S hS =>
      exact fun _ _ => H S hS
    | top =>
      simp [Presieve.isSheafFor_top P]
    | pullback X S hS _ f ih =>
      intro Y f
      rw [â† S.pullback_comp]
      exact ih (f â‰« _)
    | transitive X R S hS h H1 H2 =>
      intro Y f
      simp only [â† Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor] at *
      choose H1 H1' using H1
      choose H2 H2' using H2
      refine âŸ¨?_, fun x hx => ?_âŸ©
      Â· intro x tâ‚ tâ‚‚ hâ‚ hâ‚‚
        refine (H1 f).ext (fun Z g hg => ?_)
        refine (H2 hg (ğŸ™ _)).ext (fun ZZ gg hgg => ?_)
        simp only [Sieve.pullback_id, Sieve.pullback_apply] at hgg
        simp only [â† types_comp_apply]
        rw [â† P.map_comp, â† op_comp, hâ‚, hâ‚‚]
        simpa only [Sieve.pullback_apply, Category.assoc] using hgg
      let y : âˆ€ â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y),
        ((S.pullback (g â‰« f)).pullback (ğŸ™ _)).arrows.FamilyOfElements P :=
        fun Z g ZZ gg hgg => x (gg â‰« g) (by simpa using hgg)
      have hy : âˆ€ â¦ƒZ : Câ¦„ (g : Z âŸ¶ Y), (y g).Compatible := by
        intro Z g Yâ‚ Yâ‚‚ ZZ gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ h
        rw [hx]
        rw [reassoc_of% h]
      choose z hz using fun â¦ƒZ : Câ¦„ â¦ƒg : Z âŸ¶ Yâ¦„ (hg : R.pullback f g) =>
        H2' hg (ğŸ™ _) (y g) (hy g)
      let q : (R.pullback f).arrows.FamilyOfElements P := fun Z g hg => z hg
      have hq : q.Compatible := by
        intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ h
        apply (H2 hâ‚ gâ‚).ext
        intro ZZ gg hgg
        simp only [â† types_comp_apply]
        rw [â† P.map_comp, â† P.map_comp, â† op_comp, â† op_comp, hz, hz]
        Â· dsimp [y]; congr 1; simp only [Category.assoc, h]
        Â· simpa [reassoc_of% h] using hgg
        Â· simpa using hgg
      obtain âŸ¨t, htâŸ© := H1' f q hq
      refine âŸ¨t, fun Z g hg => ?_âŸ©
      refine (H1 (g â‰« f)).ext (fun ZZ gg hgg => ?_)
      rw [â† types_comp_apply _ (P.map gg.op), â† P.map_comp, â† op_comp, ht]
      on_goal 2 => simpa using hgg
      refine (H2 hgg (ğŸ™ _)).ext (fun ZZZ ggg hggg => ?_)
      rw [â† types_comp_apply _ (P.map ggg.op), â† P.map_comp, â† op_comp, hz]
      on_goal 2 => simpa using hggg
      refine (H2 hgg ggg).ext (fun ZZZZ gggg _ => ?_)
      rw [â† types_comp_apply _ (P.map gggg.op), â† P.map_comp, â† op_comp]
      apply hx
      simp

lemma mem_toGrothendieck_iff_of_isStableUnderComposition [IsStableUnderComposition J]
    [IsStableUnderBaseChange J] [J.HasPullbacks] [HasIsos J] {X : C} {S : Sieve X} :
    S âˆˆ J.toGrothendieck X â†” âˆƒ R âˆˆ J X, R â‰¤ S := by
  refine âŸ¨fun hS â†¦ ?_, fun âŸ¨R, hR, hleâŸ© â†¦ ?_âŸ©
  Â· induction hS with
    | of X R hR =>
      use R, hR
      exact Sieve.le_generate R
    | top X =>
      exact âŸ¨Presieve.singleton (ğŸ™ X), mem_coverings_of_isIso (ğŸ™ X), by simpâŸ©
    | pullback X S hS Y f h =>
      obtain âŸ¨R, hR, hleâŸ© := h
      have : R.HasPullbacks f := J.hasPullbacks_of_mem f hR
      refine âŸ¨R.pullbackArrows f, pullbackArrows_mem f hR, ?_âŸ©
      rw [â† Sieve.generate_le_iff, Sieve.pullbackArrows_comm]
      apply Sieve.pullback_monotone
      rwa [Sieve.generate_le_iff]
    | transitive X S T hS hT hleS hleT =>
      obtain âŸ¨R, hR, hleâŸ© := hleS
      rw [mem_iff_exists_zeroHypercover] at hR
      obtain âŸ¨E, rflâŸ© := hR
      replace hleT (i : E.Iâ‚€) : âˆƒ (F : J.ZeroHypercover (E.X i)),
          F.presieveâ‚€ â‰¤ (Sieve.pullback (E.f i) T).arrows := by
        obtain âŸ¨R', hR', hle'âŸ© := hleT (hle _ âŸ¨iâŸ©)
        rw [mem_iff_exists_zeroHypercover] at hR'
        obtain âŸ¨F, rflâŸ© := hR'
        use F
      choose F hle' using hleT
      refine âŸ¨(E.bind F).presieveâ‚€, (E.bind F).memâ‚€, ?_âŸ©
      rw [Presieve.ofArrows_le_iff]
      intro i
      exact hle' _ _ âŸ¨i.sndâŸ©
  Â· rw [â† Sieve.generate_le_iff] at hle
    apply GrothendieckTopology.superset_covering _ hle
    exact generate_mem_toGrothendieck hR

lemma toGrothendieck_toPretopology_eq_toGrothendieck [IsStableUnderComposition J]
    [IsStableUnderBaseChange J] [Limits.HasPullbacks C] [HasIsos J] :
    J.toPretopology.toGrothendieck = J.toGrothendieck := by
  ext
  exact J.mem_toGrothendieck_iff_of_isStableUnderComposition.symm

end Precoverage

@[grind .]
lemma Presieve.IsSheaf.isSheafFor_of_mem_precoverage {J : Precoverage C} {P : Cáµ’áµ– â¥¤ Type*}
    (h : Presieve.IsSheaf J.toGrothendieck P) {S : C} {R : Presieve S}
    (hR : R âˆˆ J S) : R.IsSheafFor P := by
  rw [J.isSheaf_toGrothendieck_iff] at h
  simpa [Presieve.isSheafFor_iff_generate] using h (f := ğŸ™ S) R hR

lemma PreZeroHypercover.isSheafFor_iff_of_iso {F : Cáµ’áµ– â¥¤ Type*} {S : C} {ğ’° ğ’± : PreZeroHypercover S}
    (e : ğ’° â‰… ğ’±) :
    ğ’°.presieveâ‚€.IsSheafFor F â†” ğ’±.presieveâ‚€.IsSheafFor F := by
  rw [Presieve.isSheafFor_iff_generate, â† Sieve.ofArrows, â† PreZeroHypercover.sieveâ‚€,
    PreZeroHypercover.sieveâ‚€_eq_of_iso e, â† Presieve.isSheafFor_iff_generate]

lemma Presieve.isSheafFor_ofArrows_comp_iff {F : Cáµ’áµ– â¥¤ Type*} {X : C} {Î¹ : Type*} {Y Z : Î¹ â†’ C}
    (g : âˆ€ i, Z i âŸ¶ X) (e : âˆ€ i, Y i â‰… Z i) :
    IsSheafFor F (ofArrows _ (fun i â†¦ (e i).hom â‰« g i)) â†” IsSheafFor F (ofArrows _ g) := by
  let ğ’° : PreZeroHypercover X := âŸ¨_, _, gâŸ©
  let ğ’± : PreZeroHypercover X := âŸ¨_, _, fun i â†¦ (e i).hom â‰« g iâŸ©
  let e : ğ’° â‰… ğ’± := PreZeroHypercover.isoMk (.refl _) (fun i â†¦ (e i).symm)
  exact PreZeroHypercover.isSheafFor_iff_of_iso e.symm

lemma Presieve.isSheafFor_singleton_iff_of_iso {F : Cáµ’áµ– â¥¤ Type*} {S X Y : C} (f : X âŸ¶ S) (g : Y âŸ¶ S)
    (e : X â‰… Y) (he : e.hom â‰« g = f) :
    (singleton f).IsSheafFor F â†” (singleton g).IsSheafFor F := by
  subst he
  rw [â† Presieve.ofArrows_pUnit.{_, _, 0}, â† Presieve.ofArrows_pUnit,
    Presieve.isSheafFor_ofArrows_comp_iff]

end CategoryTheory
