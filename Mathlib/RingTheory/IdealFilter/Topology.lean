/-
Copyright (c) 2025 Blake Farman. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Blake Farman
-/
module

public import Mathlib.RingTheory.IdealFilter.Basic
public import Mathlib.Topology.Algebra.LinearTopology
public import Mathlib.Topology.Algebra.FilterBasis

/-!
# Topologies associated to ideal filters

This file constructs topological structures on a ring from an `IdealFilter` and characterizes
uniform ideal filters in terms of ring filter bases.

## Main definitions
* `WithIdealFilter`: Type synonym for a ring that depends on a choice of ideal filter. This can be
used to assign and infer instances on a ring that depend on an ideal filter.
* `IdealFilter.addGroupFilterBasis`: the `AddGroupFilterBasis` with sets the ideals of `F`.
* `IdealFilter.ringFilterBasis`: under `[F.IsUniform]`, the `RingFilterBasis` with sets the ideals
of `F`.

## Main statements

* `IdealFilter.isUniform_iff_exists_ringFilterBasis`: An `IdealFilter` on a ring `A` is uniform if
and only if its ideals form a `RingFilterBasis` for `A`.

## References

* [nLab: Uniform filter](<https://ncatlab.org/nlab/show/uniform+filter>)

## Tags

ring theory, ideal, filter, linear topology
-/

@[expose] public section

open scoped Pointwise Topology

namespace IdealFilter

/-- The additive-group filter basis whose sets are the ideals belonging to the ideal filter `F`. -/
def addGroupFilterBasis {A : Type*} [Ring A] (F : IdealFilter A) : AddGroupFilterBasis A where
  sets := {(I : Set A) | I ‚àà F}
  nonempty := ‚ü®_, ‚ü®_, F.nonempty.choose_spec, rfl‚ü©‚ü©
  inter_sets := by
    rintro s t ‚ü®I, hI, rfl‚ü© ‚ü®J, hJ, rfl‚ü©
    exact ‚ü®I ‚äì J, ‚ü®I ‚äì J, Order.PFilter.inf_mem hI hJ, rfl‚ü©, fun _ h ‚Ü¶ h‚ü©
  zero' := by aesop
  add' := by aesop
  neg' := by aesop
  conj' := by aesop

/-- Under `[F.IsUniform]`, the ring filter basis obtained from `addGroupFilterBasis`. -/
@[simps! -isSimp sets]
def ringFilterBasis {A : Type*} [Ring A] {F : IdealFilter A} [F.IsUniform] :
    RingFilterBasis A where
  __ := F.addGroupFilterBasis
  mul' := by
    rintro U ‚ü®I, hI, rfl‚ü©
    exact ‚ü®I, ‚ü®I, hI, rfl‚ü©, Set.mul_subset_iff.mpr fun _ h‚ÇÅ _ h‚ÇÇ ‚Ü¶ mul_mem h‚ÇÅ h‚ÇÇ‚ü©
  mul_left' := by
    rintro x‚ÇÄ U ‚ü®I, hI, rfl‚ü©
    exact ‚ü®I, ‚ü®I, hI, rfl‚ü©, fun a ha ‚Ü¶ Ideal.mul_mem_left I x‚ÇÄ ha‚ü©
  mul_right' := by
    rintro x‚ÇÄ U ‚ü®I, hI, rfl‚ü©
    refine ‚ü®I.colon {x‚ÇÄ}, ‚ü®I.colon {x‚ÇÄ}, IsUniform.colon_mem hI x‚ÇÄ, rfl‚ü©,
      fun a ha ‚Ü¶ Set.mem_preimage.mpr (Submodule.mem_colon_singleton.mp ha)‚ü©

/-- An `IdealFilter` on a ring `A` is uniform if and only if its ideals form a `RingFilterBasis`
for `A`. -/
theorem isUniform_iff_exists_ringFilterBasis {A : Type*} [Ring A] {F : IdealFilter A} :
    F.IsUniform ‚Üî ‚àÉ B : RingFilterBasis A, B.sets = {(I : Set A) | I ‚àà F} := by
  refine ‚ü®fun _ ‚Ü¶ ‚ü®F.ringFilterBasis, rfl‚ü©, fun ‚ü®B, hB‚ü© ‚Ü¶ ‚ü®fun {I} hI a ‚Ü¶ ?_‚ü©‚ü©
  obtain ‚ü®V, hbasis, hsub‚ü© := B.mul_right a (U := I) (hB.ge (by simpa))
  obtain ‚ü®J, hJ, rfl‚ü© := hB.le hbasis
  exact Order.PFilter.mem_of_le (fun x hx ‚Ü¶ by simpa using (hsub hx)) hJ

end IdealFilter

/-- Type synonym for a ring that depends on a choice of ideal filter. We use this to assign a
topology generated by the ideal filter. -/
@[nolint unusedArguments]
def WithIdealFilter {A : Type*} [Ring A] : IdealFilter A ‚Üí Type _ := fun _ => A

namespace WithIdealFilter

open IdealFilter

variable {A : Type*} [Ring A] {F : IdealFilter A}

instance instRing : Ring (WithIdealFilter F) := inferInstanceAs (Ring A)

/-- View an ideal of `A` as a subset of `WithIdealFilter F`. -/
abbrev idealSet (I : Ideal A) : Set (WithIdealFilter F) := (I : Set A)

/-- The topology on `A` induced by `addGroupFilterBasis`. -/
instance instTopologicalSpace : TopologicalSpace (WithIdealFilter F) :=
  F.addGroupFilterBasis.topology

/-- The topology `F.addGroupFilterBasis.topology` endows `A` with the structure of a topological
additive group. -/
instance instIsTopologicalAddGroup : IsTopologicalAddGroup (WithIdealFilter F) :=
  F.addGroupFilterBasis.isTopologicalAddGroup

/-- A set `s` is a neighbourhood of `a` iff it contains a left-additive coset of some ideal
`I ‚àà F`. -/
lemma mem_nhds_iff {a : (WithIdealFilter F)} {s : Set (WithIdealFilter F)} :
    s ‚àà ùìù a ‚Üî ‚àÉ I ‚àà F, a +·µ• idealSet I ‚äÜ s := by
  constructor
  ¬∑ intro hs
    rcases ((F.addGroupFilterBasis).nhds_hasBasis a).mem_iff.1 hs with ‚ü®t, ht, hts‚ü©
    rcases ht with ‚ü®I, hI, rfl‚ü©
    exact ‚ü®I, hI, hts‚ü©
  ¬∑ rintro ‚ü®I, hI, hIs‚ü©
    refine ((F.addGroupFilterBasis).nhds_hasBasis a).mem_iff.2 ?_
    exact ‚ü®I, ‚ü®I, hI, rfl‚ü©, hIs‚ü©

/-- A set `s` is a neighbourhood of `0` iff it contains an ideal belonging to `F`. -/
lemma mem_nhds_zero_iff {s : Set (WithIdealFilter F)} :
    s ‚àà ùìù 0 ‚Üî ‚àÉ I ‚àà F, idealSet I ‚äÜ s := by
  simpa [zero_vadd] using mem_nhds_iff (a := 0) (s := s)

/-- The topology is linear in the sense that `ùìù 0` has a basis of ideals. -/
instance instIsLinearTopology : IsLinearTopology (WithIdealFilter F) (WithIdealFilter F) :=
  IsLinearTopology.mk_of_hasBasis' (R := (WithIdealFilter F))
    (M := (WithIdealFilter F))
    (Œπ := Ideal A) (S := Ideal A)
    (p := fun I : Ideal A ‚Ü¶ I ‚àà F) (s := fun I : Ideal A ‚Ü¶ I)
    ‚ü®fun _ ‚Ü¶ mem_nhds_zero_iff‚ü©
    (fun I a _ hm ‚Ü¶ Submodule.smul_mem I a hm)

/-- Under `[F.IsUniform]`, `A` is a topological ring with the induced topology. -/
instance instIsTopologicalRing [F.IsUniform] : IsTopologicalRing (WithIdealFilter F) :=
  F.ringFilterBasis.isTopologicalRing

end WithIdealFilter
