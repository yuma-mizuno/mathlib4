/-
Copyright (c) 2026 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Edward van de Meent, Christian Merten
-/
module

public import Mathlib.CategoryTheory.Sites.Canonical
public import Mathlib.CategoryTheory.Sites.JointlySurjective
public import Mathlib.CategoryTheory.Sites.MorphismProperty
public import Mathlib.Topology.Category.TopCat.Limits.Pullbacks

/-!

# The Grothendieck topology on `TopCat`

In this file we define the standard Grothendieck topology on `TopCat`. This is the topology
generated by families of jointly surjective open embeddings.

## Main definitions and results

- `TopCat.isOpenEmbedding`: The morphism property in `TopCat` given by open embeddings.
- `TopCat.grothendieckTopology`: The Grothendieck topology generated by families of jointly
  surjective open embeddings.
- `TopCat.subcanonical_grothendieckTopology`: The Grothendieck topology on `TopCat` is subcanonical.

## TODOs

- Define the √©tale precoverage on `TopCat` (replace open embedding by local homeomorphism
  in the definition of the Grothendieck topology) and show it induces the same Grothendieck
  topology.

-/

@[expose] public section

universe u

open CategoryTheory Limits

namespace TopCat

/-- The morphism property on the category of topological spaces given by open embeddings. -/
def isOpenEmbedding : MorphismProperty TopCat :=
  fun _ _ f ‚Ü¶ Topology.IsOpenEmbedding f

@[simp]
lemma isOpenEmbedding_iff {X Y : TopCat} (f : X ‚ü∂ Y) :
    isOpenEmbedding f ‚Üî Topology.IsOpenEmbedding f := .rfl

instance : isOpenEmbedding.IsMultiplicative where
  id_mem _ := .id
  comp_mem _ _ hf hg := hg.comp hf

instance : isOpenEmbedding.RespectsIso :=
  MorphismProperty.respectsIso_of_isStableUnderComposition fun _ _ f (_ : IsIso f) ‚Ü¶
    (TopCat.homeoOfIso (asIso f)).isOpenEmbedding

instance : isOpenEmbedding.IsStableUnderBaseChange :=
  .mk' fun _ _ _ _ _ _ hg ‚Ü¶ fst_isOpenEmbedding_of_right _ hg

/-- The precoverage on `TopCat` given by jointly surjective families of open embeddings. -/
def precoverage : Precoverage TopCat.{u} :=
    Types.jointlySurjectivePrecoverage.comap (forget TopCat) ‚äì isOpenEmbedding.precoverage
  deriving Precoverage.HasIsos, Precoverage.IsStableUnderBaseChange,
    Precoverage.IsStableUnderComposition

/-- The Grothendieck topology on the category of topological spaces is the topology given by
jointly surjective open embeddings. -/
abbrev grothendieckTopology : GrothendieckTopology TopCat.{u} :=
  precoverage.toGrothendieck

lemma exists_mem_zeroHypercover_range {X : TopCat} (E : precoverage.ZeroHypercover X) :
    ‚àÄ x, ‚àÉ (i : E.I‚ÇÄ), x ‚àà Set.range (E.f i) := by
  simpa using E.mem‚ÇÄ.left

lemma isOpenEmbedding_f_zeroHypercover {X : TopCat} (E : precoverage.ZeroHypercover X) :
    ‚àÄ i, Topology.IsOpenEmbedding (E.f i) := by
  simpa using E.mem‚ÇÄ.right

instance : Precoverage.Small.{u} precoverage.{u} :=
  .inf fun _ _ _ hRS hS _ _ hf ‚Ü¶ hS (hRS _ hf)

/-- The Grothendieck topology on `TopCat` is subcanonical. -/
instance subcanonical_grothendieckTopology : grothendieckTopology.Subcanonical := by
  refine .of_isSheaf_yoneda_obj _ fun X ‚Ü¶ ?_
  rw [Precoverage.isSheaf_toGrothendieck_iff_of_isStableUnderBaseChange_of_small]
  intro Y ùí∞
  rw [Presieve.isSheafFor_arrows_iff]
  have heq (i y) : ùí∞.f i y = (Subtype.val : Set.range (ùí∞.f i) ‚Üí Y) ‚ü®ùí∞.f i y, by simp‚ü© := rfl
  refine fun x hx ‚Ü¶ ‚ü®?_, fun i ‚Ü¶ ?_, fun f hf ‚Ü¶ ?_‚ü©
  ¬∑ refine ofHom <| ContinuousMap.liftCover (fun i ‚Ü¶ Set.range (ùí∞.f i)) ?_ ?_ ?_
    ¬∑ intro i
      exact ‚ü®(x i).hom ‚àò (isOpenEmbedding_f_zeroHypercover ùí∞ i).toHomeomorph.symm, by fun_prop‚ü©
    ¬∑ intro i j y
      simp only [Set.mem_range, ContinuousMap.coe_mk, Function.comp_apply, forall_exists_index]
      intro xi hi xj hj
      conv_lhs => simp only [‚Üê hi]
      conv_rhs => simp only [‚Üê hj]
      have := hx i j _ (TopCat.pullbackCone (ùí∞.f i) (ùí∞.f j)).fst
        (TopCat.pullbackCone (ùí∞.f i) (ùí∞.f j)).snd (TopCat.pullbackCone (ùí∞.f i) (ùí∞.f j)).condition
      dsimp at this
      simpa using congr($(this) ‚ü®(xi, xj), hi ‚ñ∏ hj.symm‚ü©)
    ¬∑ intro x
      obtain ‚ü®i, hi‚ü© := exists_mem_zeroHypercover_range ùí∞ x
      exact ‚ü®i, (isOpenEmbedding_f_zeroHypercover ùí∞ i).isOpen_range.mem_nhds hi‚ü©
  ¬∑ dsimp
    ext
    simp only [hom_comp, hom_ofHom, ContinuousMap.comp_apply]
    rw [heq, ContinuousMap.liftCover_coe]
    simp
  ¬∑ dsimp
    ext x
    obtain ‚ü®i, y, rfl‚ü© := exists_mem_zeroHypercover_range ùí∞ x
    have := congr($(hf i).hom y)
    dsimp at this ‚ä¢
    rw [this, heq, ContinuousMap.liftCover_coe]
    simp

end TopCat
