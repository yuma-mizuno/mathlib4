import Mathlib.CategoryTheory.Bicategory.Coherence
import Mathlib.Util.AtomM

set_option autoImplicit true

namespace Mathlib.Tactic.Bicategory

-- open Mathlib.Meta Qq NormNum Lean.Meta AtomM Lean.Elab
open Lean (MetaM Expr mkRawNatLit)
open Lean.Elab.Tactic
open CategoryTheory
-- open Lean

open Qq

-- set_option pp.collapseStructureProjections false

#check @Bicategory.whiskerRight
#check FreeBicategory.of.obj
#check Prefunctor.obj

#check Lean.ToExpr.toExpr

open Lean Elab Meta Tactic

structure Context where
  /-- The type of the ambient bicategory. -/
  B       : Expr
  /-- The universe level for objects. -/
  univObj    : Level
  /-- The universe level for morphisms. -/
  univHom    : Level
  /-- The universe level for 2-morphisms. -/
  univHom‚ÇÇ    : Level
  /-- The `Bicategory B`. -/
  inst    : Expr

abbrev M := ReaderT Context TermElabM

def Context.app (c : Context) (n : Name) (inst : Expr) : Array Expr ‚Üí Expr :=
  mkAppN (((Expr.const n [c.univHom‚ÇÇ, c.univHom, c.univObj]).app c.B).app inst)

def iapp (n : Name) (xs : Array Expr) : M Expr := do
  let c ‚Üê read
  return c.app n c.inst xs

#check FreeBicategory.of
#check Prefunctor.map
#check Bicategory.toCategoryStruct.toQuiver

universe w v u

def _root_.CategoryTheory.FreeBicategory.of' (B : Type u) [Bicategory.{w, v} B] :
    Prefunctor B (FreeBicategory B) :=
  FreeBicategory.of

-- -- set_option quotPrecheck false in
-- partial def free‚ÇÅ (e : Expr) : TermElabM Expr := do
--   -- let els := do
--   --   pure (q(FreeBicategory.of.map $f) : Expr)
--   -- let .const n _ := e.getAppFn | els
--   -- let .const n _ := (‚Üê withReducible <| whnf e).getAppFn | throwError "error not const"
--   match e, e.getAppFnArgs with
--   | _, (``CategoryStruct.comp, #[_, _, _, _, _, f, g]) =>
--     mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g]
--   | _, (``CategoryStruct.id, #[_, _, a]) =>
--     -- mkAppM ``CategoryStruct.id #[‚Üê mkAppM ``Prefunctor.obj #[.const ``FreeBicategory.of [], a]]
--     Term.elabTerm (‚Üê `(CategoryStruct.id (FreeBicategory.of.obj $(‚Üê Term.exprToSyntax a)))) none
--   | f, _ =>
--     Term.elabTerm (‚Üê `(FreeBicategory.of.map $(‚Üê Term.exprToSyntax f))) none
--     -- IO.println (‚Üê f.)

#check Quiver.Hom

#check Command.liftTermElabM

#check @Bicategory.toCategoryStruct.2
#check @Bicategory.toCategoryStruct.3
#check CategoryStruct.id

-- partial def free‚ÇÅ (e : Expr) : MetaM Expr := do
--   match ‚Üê whnfD e with
--   -- `comp`
--   | .proj ``CategoryStruct 2 e =>
--     mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g]
--   | (``CategoryStruct.id, #[a]) =>
--     let B ‚Üê inferType a
--     mkAppM ``CategoryStruct.id #[‚Üê mkAppM ``Prefunctor.obj
--       #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], a]]
--   -- | (``Bicategory.toCategoryStruct.2, #[]) =>
--   --   throwError ""
--   | (n, xs) =>
--     IO.println (n)
--     IO.println (xs)
--     IO.println <| (‚Üê whnfD e)
--     match (‚Üê inferType e).getAppFnArgs with
--     | (``Quiver.Hom, #[_, _, a, _]) =>
--       let B ‚Üê inferType a
--       mkAppM ``Prefunctor.map #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], e]
--     | _ => throwError "{e} is not a morphism"

structure LiftHom‚ÇÇ where
  /-- A 2-morphism in a bicategory -/
  hom‚ÇÇ : Expr
  /-- A lifte of `hom‚ÇÇ` in the free bicategory -/
  lift : Expr
  /-- A proof of the fact that `lift` is a lift of `hom‚ÇÇ` -/
  pr : Expr

#print FreeBicategory.normalizeIso

def normalizeHomAux {B : Type u} [Quiver.{v + 1} B] {a : B} :
    ‚àÄ {b c : B}, FreeBicategory.Hom a b ‚Üí FreeBicategory.Hom b c ‚Üí FreeBicategory.Hom a c
  | _, _, p, FreeBicategory.Hom.of f => p.comp (FreeBicategory.Hom.of f)
  | _, _, p, FreeBicategory.Hom.id _ => p
  | _, _, p, FreeBicategory.Hom.comp f g => normalizeHomAux (normalizeHomAux p f) g

def normalizeHom {B : Type u} [Quiver.{v + 1} B] {a b : B} (f : FreeBicategory.Hom a b) :
    FreeBicategory.Hom a b :=
  normalizeHomAux (FreeBicategory.Hom.id a) f

open FreeBicategory in
def normalizeHom‚ÇÇAux {B : Type u} [Quiver.{v + 1} B] {a : B} :
    ‚àÄ {b c : B} (p : FreeBicategory.Hom a b) (f : FreeBicategory.Hom b c),
      Hom‚ÇÇ (p.comp f) (normalizeHomAux p f)
  | _, _, _, Hom.of _ => Hom‚ÇÇ.id _
  | _, _, _, Hom.id b => Hom‚ÇÇ.right_unitor _
  | _, _, p, Hom.comp f g =>
    (Hom‚ÇÇ.associator_inv p f g).vcomp
      ((Hom‚ÇÇ.whisker_right g (normalizeHom‚ÇÇAux p f)).vcomp (normalizeHom‚ÇÇAux (normalizeHomAux p f) g))

open FreeBicategory in
def normalizeHom‚ÇÇInvAux {B : Type u} [Quiver.{v + 1} B] {a : B} :
    ‚àÄ {b c : B} (p : FreeBicategory.Hom a b) (f : FreeBicategory.Hom b c),
      Hom‚ÇÇ (normalizeHomAux p f) (p.comp f)
  | _, _, _, Hom.of _ => Hom‚ÇÇ.id _
  | _, _, _, Hom.id b => Hom‚ÇÇ.right_unitor_inv _
  | _, _, p, Hom.comp f g =>
    (normalizeHom‚ÇÇInvAux (normalizeHomAux p f) g).vcomp
      ((Hom‚ÇÇ.whisker_right g (normalizeHom‚ÇÇInvAux p f)).vcomp (Hom‚ÇÇ.associator p f g))

def normalizeHom‚ÇÇ {B : Type u} [Quiver.{v + 1} B] {a b : B} (f : FreeBicategory.Hom a b) :
    FreeBicategory.Hom‚ÇÇ f (normalizeHom f) :=
  (FreeBicategory.Hom‚ÇÇ.left_unitor_inv _).vcomp (normalizeHom‚ÇÇAux (FreeBicategory.Hom.id a) f)

def normalizeHom‚ÇÇInv {B : Type u} [Quiver.{v + 1} B] {a b : B} (f : FreeBicategory.Hom a b) :
    FreeBicategory.Hom‚ÇÇ (normalizeHom f) f :=
  (normalizeHom‚ÇÇInvAux (FreeBicategory.Hom.id a) f).vcomp (FreeBicategory.Hom‚ÇÇ.left_unitor _)

partial def normalize (p f : Expr) : MetaM (Expr √ó Expr) := do
  match f.getAppFnArgs with
  | (``CategoryStruct.id, _) =>
    let Œ∑ ‚Üê mkAppM ``Bicategory.rightUnitor #[p]
    return (p, Œ∑)
  -- `(Œ±_ _ _ _).symm ‚â™‚â´ whiskerRightIso (normalizeIso p f) g ‚â™‚â´ normalizeIso (normalizeAux p f) g`
  | (``CategoryStruct.comp, #[_, _, _, _, _, f, g]) =>
    let Œ∑‚ÇÄ ‚Üê normalize p f
    let Œ∑‚ÇÄ' ‚Üê normalize Œ∑‚ÇÄ.1 g
    let Œ∑‚ÇÇ := Œ∑‚ÇÄ'.2
    let Œ± ‚Üê mkAppM ``Iso.symm #[‚Üê mkAppM ``Bicategory.associator #[p, f, g]]
    let f' := Œ∑‚ÇÄ'.1
    match (Œ∑‚ÇÄ.2).getAppFnArgs with
    | (``Iso.refl, _) =>
      let Œ∑ ‚Üê mkAppM ``Iso.trans #[Œ±, Œ∑‚ÇÇ]
      return (f', Œ∑)
    | _ =>
      let Œ∑‚ÇÅ ‚Üê mkAppM ``Bicategory.whiskerRightIso #[Œ∑‚ÇÄ.2, g]
      match Œ∑‚ÇÇ.getAppFnArgs with
      | (``Iso.refl, _) =>
        let Œ∑ ‚Üê mkAppM ``Iso.trans #[Œ±, Œ∑‚ÇÅ]
        return (f', Œ∑)
      | _ =>
        let Œ∑ ‚Üê mkAppM ``Iso.trans #[Œ∑‚ÇÅ, Œ∑‚ÇÇ]
        let Œ∑ ‚Üê mkAppM ``Iso.trans #[Œ±, Œ∑]
        return (f', Œ∑)
  | _ =>
    let f' ‚Üê mkAppM ``CategoryStruct.comp #[p, f]
    let Œ∑ ‚Üê mkAppM ``Iso.refl #[f']
    return (f', Œ∑)

def Bicategory.toQuiver {B : Type} [Bicategory B] : Quiver B := inferInstance

#eval show TermElabM _ from do
  withLocalDecl `B .default (.sort (.succ (.zero))) <| fun B => do
  withLocalDecl `_h .instImplicit (mkAppN (.const ``Bicategory [ .zero,  .zero,  .zero]) #[B]) <| fun _h => do
  withLocalDecl `a .default B <| fun a => do
  withLocalDecl `b .default B <| fun b => do
  withLocalDecl `c .default B <| fun c => do
  withLocalDecl `d .default B <| fun d => do
  withLocalDecl `f .default (‚Üê mkAppOptM ``Quiver.Hom #[B, ‚Üê mkAppOptM ``Bicategory.toQuiver #[B, _h], a, b]) <| fun f => do
  withLocalDecl `g .default (‚Üê mkAppOptM ``Quiver.Hom #[B, ‚Üê mkAppOptM ``Bicategory.toQuiver #[B, _h], b, c]) <| fun g => do
  withLocalDecl `h .default (‚Üê mkAppOptM ``Quiver.Hom #[B, ‚Üê mkAppOptM ``Bicategory.toQuiver #[B, _h], c, d]) <| fun h => do
    let f ‚Üê Term.exprToSyntax f
    let g ‚Üê Term.exprToSyntax g
    let h ‚Üê Term.exprToSyntax h
    let fg ‚Üê Elab.Term.elabTermAndSynthesize (‚Üê `($f ‚â´ (ùüô _ ‚â´ $g) ‚â´ ùüô _ ‚â´ $h)) none
    IO.println (‚Üê ppExpr fg)
    IO.println (‚Üê ppExpr (‚Üê normalize (‚Üê mkAppM ``CategoryStruct.id #[a]) fg).1)
    let (e, _) ‚Üê dsimp (‚Üê mkAppM ``Iso.hom #[(‚Üê normalize (‚Üê mkAppM ``CategoryStruct.id #[a]) fg).2]) (‚Üê Simp.Context.ofNames)
    IO.println (‚Üê ppExpr e)

#eval show TermElabM _ from do
  withLocalDecl `B .default (.sort (.succ (.zero))) <| fun B => do
  withLocalDecl `_h .instImplicit (mkAppN (.const ``Bicategory [ .zero,  .zero,  .zero]) #[B]) <| fun _h => do
  withLocalDecl `a .default B <| fun a => do
  withLocalDecl `b .default B <| fun b => do
  withLocalDecl `f .default (‚Üê mkAppOptM ``Quiver.Hom #[B, ‚Üê mkAppOptM ``Bicategory.toQuiver #[B, _h], a, b]) <| fun f => do
    -- IO.println (‚Üê ppExpr (‚Üê Elab.Term.elabTermAndSynthesize (‚Üê `($(‚Üê Term.exprToSyntax f) ‚â´ $(‚Üê Term.exprToSyntax g))) none))
    let f ‚Üê Term.exprToSyntax f
    let fg ‚Üê Elab.Term.elabTermAndSynthesize (‚Üê `(ùüô _ ‚â´ $f)) none
    IO.println (‚Üê ppExpr (‚Üê normalize (‚Üê mkAppM ``CategoryStruct.id #[a]) fg).1)
    IO.println (‚Üê ppExpr (‚Üê normalize (‚Üê mkAppM ``CategoryStruct.id #[a]) fg).2)
    let (e, _) ‚Üê dsimp (‚Üê mkAppM ``Iso.hom #[(‚Üê normalize (‚Üê mkAppM ``CategoryStruct.id #[a]) fg).2]) (‚Üê Simp.Context.ofNames)
    IO.println (‚Üê ppExpr e)

partial def free‚ÇÅ (e : Expr) : MetaM Expr := do
  -- let (e, _) ‚Üê dsimp e (‚Üê Simp.Context.ofNames)
  let (``Quiver.Hom, #[_, _, a, b]) := (‚Üê whnfR <| ‚Üê inferType e).getAppFnArgs
    | throwError "{e} is not a morphism"
  let c ‚Üê mkFreshExprMVar (‚Üê inferType a)
  let f ‚Üê mkFreshExprMVar (‚Üê mkAppM ``Quiver.Hom #[a, c])
  let g ‚Üê mkFreshExprMVar (‚Üê mkAppM ``Quiver.Hom #[c, b])
  if ‚Üê isDefEq e (‚Üê mkAppM ``CategoryStruct.comp #[f, g]) then
    mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g]
  else match (‚Üê whnfR e).getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, a]) =>
      let B ‚Üê inferType a
      mkAppM ``CategoryStruct.id #[‚Üê mkAppM ``Prefunctor.obj
        #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], a]]
    | _ =>
      match (‚Üê inferType e).getAppFnArgs with
      | (``Quiver.Hom, #[_, _, a, _]) =>
        let B ‚Üê inferType a
        mkAppM ``Prefunctor.map #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], e]
      | _ => throwError "{e} is not a morphism"

-- local instance homCategory' (a b : B) : Category (FreeBicategory.Hom a b) :=
--   FreeBicategory.homCategory a b

open Term

elab "lift_to_free " t:term : term => do
  -- withMainContext do
  let f ‚Üê Term.elabTerm t none
  free‚ÇÅ f

-- syntax (name := lift_to_free) "lift" term : term

-- @[term_elab lift_to_free]
-- def liftToFreeImpl : TermElab := fun stx expectedType? => do
--   free‚ÇÅ `($stx)

def hoge {B : Type u} [Bicategory.{w, v} B] {a b : B} (f : a ‚ü∂ b) : FreeBicategory.Hom a b :=
  lift_to_free (f ‚â´ ùüô b)

#print hoge

def genAssoc {B : Type u} [Bicategory.{w, v} B] {a b : B}
    (f g : a ‚ü∂ b)
    (f' : FreeBicategory.Hom a b)
    (g' : FreeBicategory.Hom a b)
    (fg' : normalizeHom f' = normalizeHom g' := by rfl)
    (prf : (FreeBicategory.lift (ùü≠q B)).map f' = f := by rfl)
    (prg : (FreeBicategory.lift (ùü≠q B)).map g' = g := by rfl) : f ‚ü∂ g :=
  let Œπ : FreeBicategory.Hom‚ÇÇ f' g' :=
    (normalizeHom‚ÇÇ f').vcomp (FreeBicategory.Hom‚ÇÇ.vcomp (fg' ‚ñ∏ FreeBicategory.Hom‚ÇÇ.id _) (normalizeHom‚ÇÇInv g'))
  eqToHom prf.symm ‚â´ ((FreeBicategory.lift (ùü≠q B)).map‚ÇÇ <| Quot.mk _ Œπ) ‚â´ eqToHom prg

def bicategoricalComp {B : Type u} [Bicategory.{w, v} B] {a b : B}
    {f g h i : a ‚ü∂ b}
    (g' : FreeBicategory.Hom a b := lift_to_free g)
    (h' : FreeBicategory.Hom a b := lift_to_free h)
    (gh' : normalizeHom g' = normalizeHom h' := by rfl)
    (prg : (FreeBicategory.lift (ùü≠q B)).map g' = g := by rfl)
    (prh : (FreeBicategory.lift (ùü≠q B)).map h' = h := by rfl)
    (Œ∑ : f ‚ü∂ g) (Œ∏ : h ‚ü∂ i) : f ‚ü∂ i :=
  Œ∑ ‚â´ genAssoc g h g' h' gh' prg prh ‚â´ Œ∏

infixr:80 " ‚äó‚â´ " => Mathlib.Tactic.Bicategory.bicategoricalComp

example {B : Type u} [Bicategory.{w, v} B] {a b : B}
    {f : a ‚ü∂ b} : f ‚â´ ùüô b ‚ü∂ f :=
  genAssoc (f ‚â´ ùüô b) f (lift_to_free (f ‚â´ ùüô b)) (lift_to_free f)

structure bicatNormalize.Result where
  src : Expr
  tar : Expr
  hom : Array Expr
  prf : Expr

partial def bicatNormalize (n : Expr) (Œ∑ : Expr) : MetaM bicatNormalize.Result := do
  match Œ∑.getAppFnArgs with
  | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
    let ‚ü®s, t, Œ∑s, prf‚ü© ‚Üê bicatNormalize n Œ∑
    return ‚ü®s, t, Œ∑s, prf‚ü©
  | _ => throwError "Normalization failed : {Œ∑}"

-- partial def free‚ÇÅ (e : Expr) : MetaM Expr := do
--   let (e, _) ‚Üê dsimp e (‚Üê Simp.Context.ofNames)
--   match (‚Üê whnfR e).getAppFnArgs with
--   | (``CategoryStruct.comp, #[_, _, _, _, _, f, g]) =>
--     mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g]
--   | (``CategoryStruct.id, #[_, _, a]) =>
--     let B ‚Üê inferType a
--     mkAppM ``CategoryStruct.id #[‚Üê mkAppM ``Prefunctor.obj
--       #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], a]]
--   -- | (``Bicategory.toCategoryStruct.2, #[]) =>
--   --   throwError ""
--   | _ =>
--     -- IO.println (n)
--     -- IO.println (xs)
--     -- IO.println <| (‚Üê whnfR e)
--     match (‚Üê inferType e).getAppFnArgs with
--     | (``Quiver.Hom, #[_, _, a, _]) =>
--       let B ‚Üê inferType a
--       mkAppM ``Prefunctor.map #[‚Üê mkAppOptM ``FreeBicategory.of #[B, none], e]
--     | _ => throwError "{e} is not a morphism"

-- variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

-- theorem lift_map‚ÇÇ_comp {a b : FreeBicategory B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) :
--     (FreeBicategory.lift (Prefunctor.id : Prefunctor B B)).map‚ÇÇ Œ∑ =

-- partial def free‚ÇÇ (e : Expr) : MetaM LiftHom‚ÇÇ := do
--   let error : MetaM Expr := throwError "{‚Üê whnfR e} is not a structural 2-morphism"
--   -- IO.println (‚Üê ppExpr <| (‚Üê whnfR e))
--   match e.getAppFnArgs with
--   | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
--     ‚ü®e, mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÇ Œ∑, ‚Üê free‚ÇÇ Œ∏], _‚ü©
--   | (``Bicategory.whiskerLeft, #[_, _, _, _, _, f, _, _, Œ∑]) =>
--     mkAppM ``Bicategory.whiskerLeft #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÇ Œ∑]
--   | (``Bicategory.whiskerRight, #[_, _, _, _, _, _, _, Œ∑, h]) =>
--     mkAppM ``Bicategory.whiskerRight #[‚Üê free‚ÇÇ Œ∑, ‚Üê free‚ÇÅ h]
--   | (``CategoryStruct.id, #[_, _, f]) =>
--     mkAppM ``CategoryStruct.id #[‚Üê free‚ÇÅ f]
--   | (``Iso.hom, #[_, _, _, _, Œ∑]) =>
--     match (‚Üê whnfR Œ∑).getAppFnArgs with
--     | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
--       mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.associator #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g, ‚Üê free‚ÇÅ h]]
--     | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
--       mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.leftUnitor #[‚Üê free‚ÇÅ f]]
--     | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
--       mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.rightUnitor #[‚Üê free‚ÇÅ f]]
--     | _ => throwError "{‚Üê whnf Œ∑} is not a structural 2-morphism"
--   | (``Iso.inv, #[_, _, _, _, Œ∑]) =>
--     match (‚Üê whnfR Œ∑).getAppFnArgs with
--     | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
--       mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.associator #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g, ‚Üê free‚ÇÅ h]]
--     | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
--       mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.leftUnitor #[‚Üê free‚ÇÅ f]]
--     | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
--       mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.rightUnitor #[‚Üê free‚ÇÅ f]]
--     | _ => error
--   | _ => error

partial def free‚ÇÇ (e : Expr) : MetaM Expr := do
  let error : MetaM Expr := throwError "{‚Üê whnfR e} is not a structural 2-morphism"
  -- IO.println (‚Üê ppExpr <| (‚Üê whnfR e))
  match e.getAppFnArgs with
  | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
    mkAppM ``CategoryStruct.comp #[‚Üê free‚ÇÇ Œ∑, ‚Üê free‚ÇÇ Œ∏]
  | (``Bicategory.whiskerLeft, #[_, _, _, _, _, f, _, _, Œ∑]) =>
    mkAppM ``Bicategory.whiskerLeft #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÇ Œ∑]
  | (``Bicategory.whiskerRight, #[_, _, _, _, _, _, _, Œ∑, h]) =>
    mkAppM ``Bicategory.whiskerRight #[‚Üê free‚ÇÇ Œ∑, ‚Üê free‚ÇÅ h]
  | (``CategoryStruct.id, #[_, _, f]) =>
    mkAppM ``CategoryStruct.id #[‚Üê free‚ÇÅ f]
  | (``Iso.hom, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
      mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.associator #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g, ‚Üê free‚ÇÅ h]]
    | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
      mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.leftUnitor #[‚Üê free‚ÇÅ f]]
    | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
      mkAppM ``Iso.hom #[‚Üê mkAppM ``Bicategory.rightUnitor #[‚Üê free‚ÇÅ f]]
    | _ => throwError "{‚Üê whnf Œ∑} is not a structural 2-morphism"
  | (``Iso.inv, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
      mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.associator #[‚Üê free‚ÇÅ f, ‚Üê free‚ÇÅ g, ‚Üê free‚ÇÅ h]]
    | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
      mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.leftUnitor #[‚Üê free‚ÇÅ f]]
    | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
      mkAppM ``Iso.inv #[‚Üê mkAppM ``Bicategory.rightUnitor #[‚Üê free‚ÇÅ f]]
    | _ => error
  | _ => error

#check FreeBicategory.lift

#check Pseudofunctor.toPrelaxFunctor
#check PrelaxFunctor.map‚ÇÇ

def objType (Œ∑ : Expr) : MetaM Expr := do
  let (``Quiver.Hom, #[_, _, f, _]) := (‚Üê inferType Œ∑).getAppFnArgs
    | throwError "{Œ∑} is not a morphism"
  let (``Quiver.Hom, #[_, _, a, _]) := (‚Üê inferType f).getAppFnArgs
    | throwError "{f} is not a morphism"
  inferType a

def mkLiftMap‚ÇÇLiftExpr (e : Expr) : MetaM Expr := do
  -- let (``Quiver.Hom, #[_, _, f, _]) := (‚Üê whnfR <| ‚Üê inferType e).getAppFnArgs
  --   | throwError "{e} is not a morphism"
  -- let (``Quiver.Hom, #[_, _, a, _]) := (‚Üê whnfR <| ‚Üê inferType f).getAppFnArgs
  --   | throwError "{f} is not a morphism"
  let B ‚Üê objType e
  mkAppM ``PrelaxFunctor.map‚ÇÇ #[‚Üê mkAppM ``Pseudofunctor.toPrelaxFunctor
    #[‚Üê mkAppM ``FreeBicategory.lift #[‚Üê mkAppOptM ``Prefunctor.id #[B, none]]], ‚Üê free‚ÇÇ e]

-- partial def genAssoc (src tar : Expr) : MetaM Expr := do
--   match src.getAppFnArgs, tar.getAppFnArgs with
--   | (``CategoryStruct.comp, #[_, _, _, _, _, f, g]), (``CategoryStruct.comp, #[_, _, _, _, _, f', h]) =>
--     mkAppM ``Bicategory.whiskerLeft #[f, ‚Üê genAssoc g h]
--   | _, _ => throwError "genAssoc failed"

-- instance genAssoc.whiskerLeft (f : a ‚ü∂ b) (g h : b ‚ü∂ c) [LiftHom f] [LiftHom g] [LiftHom h]
--     [BicategoricalCoherence g h] : BicategoricalCoherence (f ‚â´ g) (f ‚â´ h) :=
--   ‚ü®f ‚óÅ BicategoricalCoherence.hom g h‚ü©

-- inductive genAssoc : Type where
--   | id (f : Expr) : genAssoc
--   | assoc (f g h : Expr) : genAssoc
--   | assocInv (f g h : Expr) : genAssoc
--   | leftUnitor (f : Expr) : genAssoc
--   | leftUnitorInv (f : Expr) : genAssoc
--   | rightUnitor (f : Expr) : genAssoc
--   | rightUnitorInv (f : Expr) : genAssoc
--   | whiskerLeft (f : Expr) (Œ∑ : genAssoc) : genAssoc
--   | whiskerRight (f : Expr) (Œ∑ : genAssoc) : genAssoc

partial def genAssoc (src tar : Expr) : MetaM Expr := do
  let (``Quiver.Hom, #[_, _, _a, _]) := (‚Üê whnfR <| ‚Üê inferType src).getAppFnArgs
    | throwError "{src} is not a morphism"
  let B ‚Üê inferType _a
  let a ‚Üê mkFreshExprMVar B
  let b ‚Üê mkFreshExprMVar B
  let c ‚Üê mkFreshExprMVar B
  let f ‚Üê mkFreshExprMVar (‚Üê mkAppM ``Quiver.Hom #[a, b])
  let g ‚Üê mkFreshExprMVar (‚Üê mkAppM ``Quiver.Hom #[b, c])
  let h ‚Üê mkFreshExprMVar (‚Üê mkAppM ``Quiver.Hom #[b, c])

  if ‚Üê isDefEq src (‚Üê mkAppM ``CategoryStruct.comp #[f, g]) then
    if ‚Üê isDefEq tar (‚Üê mkAppM ``CategoryStruct.comp #[f, h]) then
      mkAppM ``Bicategory.whiskerLeft #[f, ‚Üê genAssoc g h]
    else throwError "genAssoc failed"
  else


    match src.getAppFnArgs, tar.getAppFnArgs with
    | (``CategoryStruct.comp, #[_, _, _, _, _, f, g]), (``CategoryStruct.comp, #[_, _, _, _, _, f', h]) =>
      mkAppM ``Bicategory.whiskerLeft #[f, ‚Üê genAssoc g h]
    | _, _ => throwError "genAssoc failed"

open Lean Elab Tactic Meta

/-- Helper function for throwing exceptions. -/
def exception (g : MVarId) (msg : MessageData) : MetaM Œ± :=
  throwTacticEx `bicategorical_coherence g msg

/-- Coherence tactic for bicategories. -/
def bicategory_coherence (g : MVarId) : MetaM Unit := g.withContext do
  -- TODO: is this `dsimp only` step necessary? It doesn't appear to be in the tests below.
  -- let (ty, _) ‚Üê dsimp (‚Üê g.getType) (‚Üê Simp.Context.ofNames [] true)
  let ty ‚Üê g.getType
  let some (_, lhs, rhs) := (‚Üê whnfR ty).eq? | exception g "Not an equation of morphisms."
  let lift_lhs ‚Üê mkLiftMap‚ÇÇLiftExpr lhs
  let lift_rhs ‚Üê mkLiftMap‚ÇÇLiftExpr rhs
  -- This new equation is defeq to the original by assumption
  -- on the `LiftHom` instances.
  let g‚ÇÅ ‚Üê g.change (‚Üê mkEq lift_lhs lift_rhs)
  IO.println (‚Üê ppExpr (‚Üê g‚ÇÅ.getType))
  let [g‚ÇÇ] ‚Üê g‚ÇÅ.applyConst ``congrArg
    | exception g "congrArg failed in coherence"
  let [] ‚Üê g‚ÇÇ.applyConst ``Subsingleton.elim
    | exception g "This shouldn't happen; Subsingleton.elim does not create goals."

-- #check ReaderT.run (r := c)

elab "bicategory_coherence" : tactic => do bicategory_coherence (‚Üê getMainGoal)

end Mathlib.Tactic.Bicategory

section Bicategory

open CategoryTheory
open scoped Bicategory


variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

example {a : B} (f : a ‚ü∂ a) : ùüô f ‚ñ∑ f = ùüô (f ‚â´ f) := by whisker_simps

example (a b : ‚Ñ§) : a + b = b + a := by bicategory_coherence

example : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom := by bicategory_coherence
example : (Œª_ (ùüô a)).inv = (œÅ_ (ùüô a)).inv := by bicategory_coherence
example (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
  (Œ±_ f g h).inv ‚â´ (Œ±_ f g h).hom = ùüô (f ‚â´ g ‚â´ h) :=
by bicategory_coherence
example (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
  Iso.inv (Œ±_ f g h) ‚â´ Iso.hom (Œ±_ f g h) = ùüô (f ‚â´ g ‚â´ h) :=
by bicategory_coherence

-- @[simp]
def comp' (f : a ‚ü∂ b) (g : b ‚ü∂ c) := f ‚â´ g

example (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) (i : d ‚ü∂ e) :
  f ‚óÅ (Œ±_ g h i).hom ‚â´ (Œ±_ f g (h ‚â´ i)).inv ‚â´ (Œ±_ (comp' f g) h i).inv =
    (Œ±_ f (g ‚â´ h) i).inv ‚â´ (Œ±_ f g h).inv ‚ñ∑ i := by
  bicategory_coherence

example (f : a ‚ü∂ b) (g : b ‚ü∂ c) :
  f ‚óÅ (Œª_ g).inv ‚â´ (Œ±_ f (ùüô b) g).inv = (œÅ_ f).inv ‚ñ∑ g :=
by bicategory_coherence

example : ùüô (ùüô a ‚â´ ùüô a) ‚â´ (Œª_ (ùüô a)).hom = ùüô (ùüô a ‚â´ ùüô a) ‚â´ (œÅ_ (ùüô a)).hom := by
  bicategory_coherence

example (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :
  (CategoryTheory.Bicategory.associator (ùüô a) f ((ùüô b ‚â´ g) ‚â´ ùüô c ‚â´ h)).inv ‚â´
  CategoryTheory.Bicategory.whiskerRight (ùüô (ùüô a ‚â´ f)) ((ùüô b ‚â´ g) ‚â´ ùüô c ‚â´ h) ‚â´
    (CategoryTheory.Bicategory.associator (ùüô a ‚â´ f) (ùüô b ‚â´ g) (ùüô c ‚â´ h)).inv ‚â´
      CategoryTheory.Bicategory.whiskerRight
          ((CategoryTheory.Bicategory.associator (ùüô a ‚â´ f) (ùüô b) g).inv ‚â´
            CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (ùüô a ‚â´ f)).hom g ‚â´
              ùüô ((ùüô a ‚â´ f) ‚â´ g))
          (ùüô c ‚â´ h) ‚â´
        (CategoryTheory.Bicategory.associator ((ùüô a ‚â´ f) ‚â´ g) (ùüô c) h).inv ‚â´
          CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor ((ùüô a ‚â´ f) ‚â´ g)).hom h ‚â´
            ùüô (((ùüô a ‚â´ f) ‚â´ g) ‚â´ h) =
  (CategoryTheory.Bicategory.associator (ùüô a) f ((ùüô b ‚â´ g) ‚â´ ùüô c ‚â´ h)).inv ‚â´
  (CategoryTheory.Bicategory.associator (ùüô a ‚â´ f) (ùüô b ‚â´ g) (ùüô c ‚â´ h)).inv ‚â´
    CategoryTheory.Bicategory.whiskerRight
        ((CategoryTheory.Bicategory.associator (ùüô a ‚â´ f) (ùüô b) g).inv ‚â´
          CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (ùüô a ‚â´ f)).hom g)
        (ùüô c ‚â´ h) ‚â´
      (CategoryTheory.Bicategory.associator ((ùüô a ‚â´ f) ‚â´ g) (ùüô c) h).inv ‚â´
        CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor ((ùüô a ‚â´ f) ‚â´ g)).hom h := by
bicategory_coherence

set_option profiler true in
example (f‚ÇÅ : a ‚ü∂ b) (f‚ÇÇ : b ‚ü∂ c) :
  (Œ±_ (ùüô a) (ùüô a) (f‚ÇÅ ‚â´ f‚ÇÇ)).hom ‚â´
    ùüô a ‚óÅ (Œ±_ (ùüô a) f‚ÇÅ f‚ÇÇ).inv ‚â´
      ùüô a ‚óÅ ((Œª_ f‚ÇÅ).hom ‚â´ (œÅ_ f‚ÇÅ).inv) ‚ñ∑ f‚ÇÇ ‚â´
        ùüô a ‚óÅ (Œ±_ f‚ÇÅ (ùüô b) f‚ÇÇ).hom ‚â´
          (Œ±_ (ùüô a) f‚ÇÅ (ùüô b ‚â´ f‚ÇÇ)).inv ‚â´
            ((Œª_ f‚ÇÅ).hom ‚â´ (œÅ_ f‚ÇÅ).inv) ‚ñ∑ (ùüô b ‚â´ f‚ÇÇ) ‚â´
              (Œ±_ f‚ÇÅ (ùüô b) (ùüô b ‚â´ f‚ÇÇ)).hom ‚â´
                f‚ÇÅ ‚óÅ ùüô b ‚óÅ ((Œª_ f‚ÇÇ).hom ‚â´ (œÅ_ f‚ÇÇ).inv) ‚â´
                  f‚ÇÅ ‚óÅ (Œ±_ (ùüô b) f‚ÇÇ (ùüô c)).inv ‚â´
                    f‚ÇÅ ‚óÅ ((Œª_ f‚ÇÇ).hom ‚â´ (œÅ_ f‚ÇÇ).inv) ‚ñ∑ ùüô c ‚â´
                      (f‚ÇÅ ‚óÅ (Œ±_ f‚ÇÇ (ùüô c) (ùüô c)).hom) ‚â´
                        (Œ±_ f‚ÇÅ f‚ÇÇ (ùüô c ‚â´ ùüô c)).inv =
  ((Œª_ (ùüô a)).hom ‚ñ∑ (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ (Œª_ (f‚ÇÅ ‚â´ f‚ÇÇ)).hom ‚â´ (œÅ_ (f‚ÇÅ ‚â´ f‚ÇÇ)).inv) ‚â´
    (f‚ÇÅ ‚â´ f‚ÇÇ) ‚óÅ (Œª_ (ùüô c)).inv :=
by bicategory_coherence

example (f g : a ‚ü∂ a) (Œ∑ : ùüô a ‚ü∂ f) (Œ∏ : f ‚ü∂ g) (w : false) :
  (Œª_ (ùüô a)).hom ‚â´ Œ∑ ‚â´ Œ∏ = (œÅ_ (ùüô a)).hom ‚â´ Œ∑ ‚â´ Œ∏ :=
by bicategory_coherence

end Bicategory
